<!DOCTYPE HTML>
<html>

<head>
	<meta charset="utf-8">
	<script src="jquery-2.2.0.js"></script>
	<!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>-->
	<script src="props_manager.js"></script>
	<script src="parser.js"></script>
	<script src="jjv.js"></script>
	<script src="meta_schema.js"></script>
	<style>
		body{
			padding:10px;
			margin:0px;
		}
		.shadow {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: #000;
			opacity: 0.3;
		}
		.common-dialog {
			position: fixed;
			left: 50%;			/*по горизонтали*/
			transform: translateX(-50%);
			max-width: 95%;		/*по вертикали*/
			top: 5%;
			box-sizing: border-box;	/*что бы padding не влиял на высоту*/
			max-height: 90%;
			overflow : auto;	/*полосы прокрутки*/
			background: #fff;
			border: 1px solid #000;
			padding: 10px;		
		}
		/*----*/
		.noun-dialog{
			text-align: center
		}
		.noun-dialog div{
			margin:4px;
			white-space:nowrap;
		}
		.noun-dialog button{
			margin-left:5px;
			margin-right:5px;
		}
		.noun-dialog .button-set{
			text-align:right
		}
		.noun-dialog .anchor{
			display: none;
		}
		.noun-table{
			text-align: left;
			margin: auto
		}
		.noun-table td{
			height:24px;
		}
		/*----*/
		select.fixed{
			background-color: #0f0;
		}
	</style>
</head>
<body>
	User Name:
	<select id="user_name"></select>
	<span id="current_user"></span>
	<br>

	<input type="text" id="in_text" size="120"/>
	<button onclick="dialog_add_word($('#in_text').val())">add noun</button>

	<hr/>
	<div  id="unknown_words"/>
<script>
'use strict';
copyProps(Parser,window);
var parse_URI = /^((?:[^:\/?#]+):)?(?:\/\/(([^:\/?#]*)(?::([^:\/?#]*))?))?([^?#]*)(\?([^#]*))?(#(.*))?\s*$/;
//                1x           x 1 x      23         3x   4         4x 2x 5      56  7     76 8 9  98
/*	lication.
\0	href		http://www.google.com:80/search?q=javascript#test
\1	protocol	http:
\2	host		www.google.com:80
\3	hostname	www.google.com
\4	port		80
\5	pathname	/search
\6	search		?q=javascript
\7				q=javascript
\8	hash		#test
\9				test
*/
/*
 * при клике ЛКМ на ссылку парсится ее href и открывается dialog_add_word, 
 * а для открытия в новом окне - это обычная ссылка
 * + функции добавления и снятия такого поведения
 */
function click_internal_link_word_handler(event){
	if(event.which==1){// ЛКМ
		event.preventDefault();
		var options = parse_URI_params(parse_URI.exec($(this).attr('href'))[6]);
		//console.dir(options);
		dialog_add_word(options.word,options);
	}
}
/*
 * создает события select_select, его надо вешать на click
 */
function click_handler_select_select(event){
	var pos = this.getBoundingClientRect();
	if(!(event.clientX>=pos.left && event.clientX<pos.right && 
			event.clientY>=pos.top && event.clientY<pos.bottom)){
		$(this).trigger('select_select');
	}
}
/*
 * создает события fix_select и unfix_select, его надо вешать на select_select
 * требует следующей инициализации
 * .prepend('<option value="">не фиксировать</option>').find('option[value=""]').hide();
 */
function select_handler_fix_unfix_select(ev){
	var $this = $(this);
	if($this.val()==''){ // выбрали не фиксировать
		$this.removeClass('fixed').find('option[value=""]').hide();
		$this.trigger('unfix_select');
	}
	else{ // выбрали элемент
		if(!$this.hasClass('fixed'))
			$this.addClass('fixed').find('option[value=""]').show();
		$this.trigger('fix_select');
	}
}
/*
 * совершаем change и кидаем событие change
 */
function set_value(obj,value){
  obj.value = value;
  $(obj).trigger('change')
}
function set_checked(obj,checked){
  obj.checked = checked;
  $(obj).trigger('change')
}
/*
 * диалоговое окно, которое можно вызывать одно поверх ругого стеком
 * запрещает переходы на элементы вне его мышкой и табуляцией
 * а так же обрабатывает esc
 */
function Dialog() {
	this._$base = $('<div><div class="shadow"></div></div>');
	var self = this;
	this.onkeydown = function(event){
		if(event.keyCode==27){//ESC
			// главное, что бы более новые обработчики вызывались раньше более старых
			event.stopImmediatePropagation();
			self.close();
		}
	}
}
Dialog.prototype = {
	constructor: Dialog,
	show: function ($element) {
		this.$tabable = $('input[tabindex!="-1"],textarea[tabindex!="-1"],\
			button[tabindex!="-1"],select[tabindex!="-1"],a[tabindex!="-1"],\
			[contenteditable="true"][tabindex!="-1"],datalist[tabindex!="-1"],\
			meter[tabindex!="-1"],progress[tabindex!="-1"]'
		);
		//console.dir(this.$tabable);
		this.$tabable.each(function(){
			var $this = $(this);
			console.assert($this.data('stored_tabindex')===undefined);
			var tmp = $this.attr('tabindex')
			$this.data('stored_tabindex',tmp?tmp:0);
			$this.attr('tabindex','-1');
		});
		$element.addClass("common-dialog");
		this._$base.append($element).appendTo($("body"));
		$(window).on('keydown',this.onkeydown);
	},
	close: function () {
		this.$tabable.each(function(){
			var $this = $(this);
			var tmp = $this.data('stored_tabindex');
			$this.attr('tabindex',tmp);
			$this.removeData('stored_tabindex');
		});
		this._$base.remove();
		$(window).off('keydown',this.onkeydown);
	}
};

var css_padej_classes = {
	"ип":"i-padej",
	"рп":"r-padej",
	"дп":"d-padej",
	"вп":"v-padej",
	"тп":"t-padej",
	"пп":"p-padej"
};
var padej_words = {
	"ип":[""],
	"рп":["нет"],
	"дп":["дать"],
	"вп":["вижу"],
	"тп":["творю"],
	"пп":["о","об"]
};
function invert_num(str){
	if(str=='мн')	return 'ед';
	if(str=='ед')	return 'мн';
}
function noun2plural(word){
	if(/мя$/.test(word))	return word.replace(/^(.*)мя$/,'$1мена');
	if(/ец$/.test(word))	return word.replace(/^(.*)ец$/,'$1цы');
	if(/ие$/.test(word))	return word.replace(/^(.*)ие$/,'$1ия');
	if(/ье$/.test(word))	return word.replace(/^(.*)ье$/,'$1ья');
	if(/ий$/.test(word))	return word.replace(/^(.*)ий$/,'$1ии');
	if(/ия$/.test(word))	return word.replace(/^(.*)ия$/,'$1ии');

	if(/[оёе]к$/.test(word))return word.replace(/^(.*)[оёе]к$/,'$1ки');
	if(/[кгчхш]$/.test(word))	return word.replace(/^(.*)$/,'$1и');
	if(/[^аоуыиэюяеёь]$/.test(word)) return word.replace(/^(.*)$/,'$1ы');// исключение: стул
	
	if(/[кгчшх]а$/.test(word))	return word.replace(/^(.*)а$/,'$1и');
	if(/а$/.test(word))		return word.replace(/^(.*)а$/,'$1ы');
	
	if(/[^и]o$/.test(word))	return word.replace(/^(.*)о$/,'$1а');
	if(/[яйь]$/.test(word))	return word.replace(/^(.*)[яйь]$/,'$1и');
	if(/[еи]$/.test(word))	return word;// несклоняемые
	console.log('не смог придумать множественное число для '+word);
	return word;
}
function noun2singular(word, gender){
	gender = gender || 'ж';
	if(/мена$/.test(word))	return word.replace(/^(.*)мена$/,'$1мя');
	if(/ия$/.test(word))	return word.replace(/^(.*)ия$/,'$1ии');
	if(/ии$/.test(word))	
		if(gender=='ж')		return word.replace(/^(.*)ий$/,'$1ия');
		else				return word.replace(/^(.*)ия$/,'$1ий');
	if(/ы$/.test(word))	
		if(gender=='ж')		return word.replace(/^(.*)ы$/,'$1а');
		else				return word.replace(/^(.*)ы$/,'$1');
	if(/и$/.test(word))	
		if(gender=='ж')		return word.replace(/^(.*)и$/,'$1ь');
		else				return word.replace(/^(.*)и$/,'$1');
	if(/ра$/.test(word))	return word.replace(/^(.*)а$/,'$1');
	if(/а$/.test(word))	return word.replace(/^(.*)а$/,'$1о');
	if(/[еи]$/.test(word))	return word;// несклоняемые
	console.log('не смог придумать единственное число для '+word);
	return word;
}

function dialog_add_noun(word,options){
	"use strict";
	options = options || {};
	// === переменные, которые в процессе диалога не меняются ================================================
	// ни чего не меняем, просто проверяем непротиворечивость существующего и рекомендованного числа слова
	if(word in DB.nouns && options && options.число && options.число!=DB.nouns[word].type.число){
		alert('Что-то не совпадает: \n'+
			options.other_num+' - '+invert_num(options.число)+'. число\n ссылается на \n'+
			word+' - '+DB.nouns[word].type.число+'. число\n как на то же слово в другом числе'
		);
	}
		
	// заполняем массив с подходящими склонениями, и сортируем по релевантности
	// а именно по окончаниям
	var proper_types = [];
	(function(proper_types){ // инициализация и сортировка подходящих склонений
		var find_needed_num = false;
		for( var i in DB.noun_types ){
			var rgx = new RegExp(DB.noun_types[i].ип+'$');
			var res; 
			if( res = rgx.exec(word) ){
				proper_types.push({
					link:DB.noun_types[i],
					r:word.length-res.index,
					available:true,
					name: i,
				});
			}
		}
		proper_types.sort((l,r)=>(l.r-r.r));// по убыванию по .r
	})(proper_types);
	//console.dir(proper_types);
	
	// === элементы, которые в процессе диалога не меняются ====================================================
	// #todo расставить title-ы - подсказки
	var $form = $('\
		<form class="noun-dialog" id="'+word+'">\
 			<h2 id="selflink" style="margin-bottom:0">Существительное: \
			'+word+' <a target="_blank" class="anchor">#</a></h2>\
			<div style="">\
				<span style="display: inline-block; float:left; line-height:3em;">\
					<input type="checkbox" name="other_num_flag" id="other_num_flag"><label for="other_num_flag" id="other_num_label"></label></input>\
					<input type="text" name="other_num_edit"></input>\
					<a target="_blank" id="other_num_link">#</a>\
				</span>\
				<div style="display:inline-block;vertical-align:middle">\
					<a target="_blank" id="wiktionary_link">wiktionary</a><br>\
					<input name="wiki_flag" type="checkbox"><a id="wiki_link" target="_blank">wiki</a></input>\
				</div>\
			</div>\
			<div>\
				<select name="число">\
					<option value="ед">ед. число</option>\
					<option value="мн">мн. число</option>\
				</select>\
				<select name="род">\
					<option value="м">мужской род</option>\
					<option value="ж">женский род</option>\
					<option value="с">средний род</option>\
					<option value="о">общий род</option>\
				</select>\
				<select name="одушевленность">\
					<option value="одушевленное">одушевленное</option>\
					<option value="неодушевленное">неодушевленное</option>\
				</select>\
			</div>\
			<table id="main_table" class="noun-table"></table>\
			<div>\
				(<span id="selected"/><span id="available"/>)\
				<button type="button" name="left">&lt;-</button>\
				<button type="button" name="right">-&gt;</button>\
			</div>\
			<div>\
				<span title="ни на что не влияет">название склонения:</span>\
				<input title="ни на что не влияет" type="text" name="склонение"></input>\
			</div>\
			<br/>комментарий:<br/><textarea style="width: 100%"></textarea>\
			<div class="button-set">\
				<button type="button" name="reset">как было</button>\
				<button type="button" name="OK">добавить</button>\
				<button type="button" name="cancel">назад</button>\
			</div>\
		</form>\
	');
	var form = $form[0];
	var $table = $form.find('#main_table');
	var $style = $('<style/>').appendTo($('head'));
	var sheet = $style[0].sheet;

	// настройка элементов, которые в процессе диалога не меняются
	function static_init(){
		//console.log('static_init');
		//настройка самоссылки
		var $self = $form.find('#selflink');
		var $a = $self.find('a').attr('href',location.pathname + make_URI_params({word:word}));
		$self.hover(function(){$a.show();},function(){$a.hide();})
		
		// заполняем падежными словами
		var $tr = $(
			'<tr>\
				<td class="define"></td>\
				<td class="word"></td>\
			</tr>'
		);
		for(var x in css_padej_classes){
			$table.append($tr.clone().addClass(css_padej_classes[x]).find('.define').text(padej_words[x][0]).end());
		}
		if(['а','о','у','ы','и','э'].indexOf(word[0])!=-1) { //обработка о/об
			$table.find('.'+css_padej_classes['пп']+' .define').text(padej_words['пп'][1]);// пробел необходим
		}

		// инициализируем число, род, одушевленность
		$(form.число).add(form.род).add(form.одушевленность).click(click_handler_select_select)
			.on('select_select',select_handler_fix_unfix_select)
			.prepend('<option value="">не фиксировать</option>').find('option[value=""]').hide();
			
		// устанавливаем ширину edit-ов
		var $tmp = $('<select><option>'+word+'</option></select>').appendTo($('body'));
		var width = $tmp.width();
		$tmp.remove();
		sheet.insertRule('#'+word+' input[type="text"]{ width:'+width+'px}',sheet.cssRules.length);
		$(form.склонение).width(100);
	}
	static_init();
	
	// === поведенческие функции и обработчики без глобальных переменных ======================================
	function update_wiki_link(){
		//console.log('update_wiki_link');
		var text;
		if(form.other_num_flag.checked && form.число.value=='мн')
			text = form.other_num_edit.value
		else text = word;
		if(form.wiki_flag.checked)
			$form.find('#wiki_link').attr('href','http://ru.wikipedia.org/wiki/'+encodeURIComponent(text));
		else
			$form.find('#wiki_link').removeAttr('href');
	}
	$(form.wiki_flag).add(form.число).add(form.other_num_edit).change(update_wiki_link);
	
	function update_wiktionary_href(){
		//console.log('update_wiktionary_href');
		var text;
		if(form.other_num_flag.checked && form.число.value=='мн')
			text = form.other_num_edit.value
		else text = word;
		$form.find('#wiktionary_link').
			attr('href','http://ru.wiktionary.org/wiki/'+encodeURIComponent(text));
	}
	$(form.other_num_flag).add(form.число).add(form.other_num_edit).change(update_wiktionary_href);
	
	function show_hide_other_num(){
		if(form.other_num_flag.checked===true){
			//.log('show_other_num');
			$(form.other_num_edit)	.show();
			$form.find('#other_num_link').show();
			if(! word in DB.nouns && !options.other_num)
				set_value(form.other_num_edit, 
					(options.число && options.число=='мн') ? noun2singular(word) : noun2plural(word)
				);				
		}
		else if(form.other_num_flag.checked===false){
			//console.log('hide_other_num');
			$(form.other_num_edit).hide();
			$form.find('#other_num_link').hide();
		}
		else 
			console.warn(form.other_num_flag.checked);
	}
	$(form.other_num_flag).change(show_hide_other_num);
	
	function update_other_num_label(){
		//console.log('update_other_num_label');
		$form.find('#other_num_label').text(invert_num(form.число.value)+'. число');
	}
	$(form.число).change(update_other_num_label);
	
	function update_other_num_href(){
		//console.log('update_other_num_href');
		$form.find('#other_num_link').attr('href',location.pathname + make_URI_params({
			word: form.other_num_edit.value,
			число: invert_num(form.число.value),
			other_num: word,
		}));
	}
	$(form.other_num_edit).add(form.число).change(update_other_num_href);
	
	function update_hum(){
		var $yes = $(form.одушевленность).find('option[value="одушевленное"]');
		var $no = $(form.одушевленность).find('option[value="неодушевленное"]');

		if(form.число.value == 'мн'){
			$yes.text('одушевлённые');
			$no.text('неодушевлённые');
		}
		else if(form.род.value == 'м'){
			$yes.text('одушевлённый');
			$no.text('неодушевлённый');
		}
		else if(form.род.value == 'ж'){
			$yes.text('одушевлённая');
			$no.text('неодушевлённая');
		}
		else if(form.род.value == 'с'){
			$yes.text('одушевлённое');
			$no.text('неодушевлённое');
		}
		else if(form.род.value == 'о'){
			$yes.text(Math.random()>0.5 ? 'одушевлённый' : 'одушевлённая');
			$no.text(Math.random()>0.5 ? 'неодушевлённый' : 'неодушевлённая');
		}
	}
	$(form.число).add(form.род).change(update_hum);
	
	// === глобальные переменные =============================================================================
	var selected = -1; // == -1 - доступные типы отсутствуют
	var selected_modified = false; // true - если ручное изменение доступного типа
	
	// === внутренние поведенческие функции и обработчики =====================================================

	function draw_proper_num(){
		if(selected == -1 || selected_modified)
			$form.find('#selected').text('новое для ');
		else
			$form.find('#selected').text('№'+proper_types[selected].name+' из ');
	}
	function select(x){ // and draw
		selected = x;
		draw_proper_num();

		if(x == -1 || selected_modified){
			is_void_sklon_name();
			// все что не заполнено - заполнить по умолчанию
			if(form.число.value=='')  set_value(form.число, 'ед');
			if(form.род.value=='') set_value(form.род, 'м');
			if(form.одушевленность.value=='') set_value(form.одушевленность, 'одушевленное');
			for(var p in css_padej_classes){
				var $td = $table.find('.'+css_padej_classes[p]+' .word');//' .word' - пробел важен
				if($td.children()[0]){
					if($td.children().val().trim()=='')
						$td.children().val(word);
				}
				else if($td.text().trim() =='')
					$td.text(word);
			}
			make_edits();
		}
		else{
			console.assert(proper_types[x]);
			var type = proper_types[x].link;
			set_value(form.число, type.число);
			set_value(form.род, type.род);
			if(type.одушевленность) set_value(form.одушевленность, 'одушевленное');
			else                    set_value(form.одушевленность, 'неодушевленное');
			set_value(form.склонение, type.склонение);
			var root = word.slice(0,(new RegExp(type.ип+'$')).exec(word).index);
			for(var p in css_padej_classes){
				$table.find('.'+css_padej_classes[p]+' .word').
					text(root+type[p]);
			}
		}
		compare_data();
	}
	
	function draw_available_count(){
		//console.log('draw_available_count');
		var cnt = 0;
		for(var i = 0; i<proper_types.length; i++)
			if(proper_types[i].available)
				cnt++;
		$form.find('#available').text(cnt+' подходящ'+(cnt===1 ? 'его' : 'их'));
	}
	function update_available(){
		//console.log('update_available');
		//console.dir(proper_types)
		// расставляем флаги кто доступен, кто нет
		for(var i = 0; i<proper_types.length; i++)
			proper_types[i].available = true;
		function filter(prop,name,transform_val){
			if($(form[name]).hasClass('fixed'))
				for(var i = 0; i<proper_types.length; i++)
					if(proper_types[i].link[prop] != transform_val(form[name].value))
						proper_types[i].available = false;
		}
		filter('число','число',r=>r);
		filter('род','род',r=>r);
		filter('одушевленность','одушевленность',r=>r==='одушевленное');
		
		draw_available_count();

		// === устанавливаем selected на доступное склонение ===
		if(selected == -1){ // из состояния ничего недоступно
			if(proper_types.length > 0) selected = 0; // начинаем поиск с 0
			else { select(-1); return; }; // остаемся в состоянии ничего недоступно
		}
		else if(proper_types[selected].available) // если доступность не изменилась
			return; // ничего не делаем
		// ищем доступные микросклонения с меньшим индексом
		for(var i = selected; i>=0; i--)
			if(proper_types[i].available){
				select(i);
				return;
			}
		// ищем доступные микросклонения с большим индексом
		for(var i = selected; i!=proper_types.length; i++)
			if(proper_types[i].available){
				select(i);
				return;
			}
		// нет доступных микросклонений
		select(-1);
	}
	$(form.число).add(form.род).add(form.одушевленность)
		.on('fix_select',update_available).on('unfix_select',update_available);
		
	function is_void_sklon_name(){
		if(!selected_modified && selected != -1) return;
		var suffix = form.число.value=='мн' ? ' мн' : '';
		if(form.other_num_edit.value in DB.nouns)
			set_value(form.склонение, DB.nouns[form.other_num_edit.value].type.склонение + suffix);
		else
			set_value(form.склонение, suffix.trim());
	}
	function generate_type(){
		//найти корень и отделить окончания
		var words = {};
		for(var p in css_padej_classes){
			var $word = $table.find('.'+css_padej_classes[p]+' .word')
			if($word.children().length==0)
				words[p] = $word.text().trim();
			else
				words[p] = $word.children().val().trim();
		}
		function diff_pos(s1,s2){
			var i;
			for(i=0; i<s1.length; i++){
				if(s1.charAt(i)!=s2.charAt(i))
					break;
			}
			return i;
		}
		var root = words['ип'];
		for(var p in words)
			root = root.slice(0,diff_pos(root,words[p]));
		var new_type = {};
		for(var p in css_padej_classes)
			new_type[p] = words[p].slice(root.length);
		new_type.число = form.число.value;
		new_type.род = form.род.value;
		new_type.одушевленность = form.одушевленность.value==='одушевленное';
		new_type.склонение = form.склонение.value;
		return new_type;
	}
	function find_sklon(){
		//console.log('find_sklon');
		var type = generate_type();
		var found = false;
		var i;
		for(i=0; i< proper_types.length; i++){
			if(!proper_types[i].available)
				continue;
			var eq = true;
			for(var p in type)
				if(p!='склонение' && type[p]!=proper_types[i].link[p]){
					eq = false;
					break;
				}
			if(eq){
				found = true;
				break;
			}
		}
		if(found){
			selected_modified = false;
			select(i);
			return;
		}
		selected_modified = true;
		is_void_sklon_name();
		compare_data();
		draw_proper_num();
	}
	function make_edits(){
		$table.find('.word').each(function(){
			var $this = $(this);
			if($this.children().length!=0)	return;
			var cur_word = $this.text();
			$this.html('<input type="text" value="'+cur_word+'"></input>');
			$this.children().change(function(event){
				if(this.value.trim()==''){
					this.value = word;
				}
				find_sklon();
			});
		})
	}
	$table.find('.word').click(function(event){
		if(event.target !== event.currentTarget) return;
		make_edits();
		$(this).children()[0].focus();
	});
		
	// смена текущего склонения
	$(form.right).click(function(){
		if(selected == -1) return;
		selected_modified = false;
		while(++selected < proper_types.length)
			if(proper_types[selected].available){
				select(selected);
				return;
			}
		for(selected = 0; selected < proper_types.length; selected++){
			if(proper_types[selected].available){
				select(selected);
				return;
			}
		}
		console.error('нет доступных склонений');
		select(-1)
	});
	$(form.left).click(function(){
		if(selected == -1) return;
		selected_modified = false;
		while(--selected >= 0)
			if(proper_types[selected].available){
				select(selected);
				return;
			}
		for(selected = proper_types.length; selected-- >0 ; ){
			if(proper_types[selected].available){
				select(selected);
				return;
			}
		}
		console.error('нет доступных склонений')
		select(-1)
	});
		
	// === внешние поведенческие функции и обработчики =====================================================

	function init_from_DB(){
		var data = DB.nouns[word];
		set_checked(form.wiki_flag, data.wiki);
		if(data.other_num){ // если имеется, то имеет приоритет над options.other_num
			set_checked(form.other_num_flag, true);
			set_value(form.other_num_edit, data.other_num);
		}
		else{
			set_checked(form.other_num_flag, false);
			set_value(form.other_num_edit, 
				(options.число && options.число=='мн') ? noun2singular(word) : noun2plural(word));
		}
		// иначе устанавливается отдельно
		for(var i = 0; i<proper_types.length; i++)
			if(proper_types[i].link === data.type){
				select(i);
				// здесь повезло, что при последовательном ограничении (число, род, одушевленность)
				// selected не должен измениться, не смотря на то, что update_available будет вызываться
				// сначала с неограниченными родом и одушевленностью, а потом с неограниченоой одушевленностью
				$(form.число).add(form.род).add(form.одушевленность).trigger('select_select');
				console.assert(selected === i);
				return;
			}
		console.error('type не найден в proper_types');
		select(-1);
	}

	function init_without_DB(){
		set_checked(form.wiki_flag, true);
		set_checked(form.other_num_flag, true);
		if(options.other_num){
			set_value(form.other_num_edit, options.other_num);
			if(options.other_num in DB.nouns){
				//console.log('other_num_init')
				var other_data = DB.nouns[options.other_num];
				set_checked(form.wiki_flag, other_data.wiki);
				set_value(form.род, other_data.type.род);
					$(form.род).trigger('select_select');
				set_value(form.одушевленность, other_data.type.одушевленность ? 'одушевленное' : 'неодушевленное');
					$(form.одушевленность).trigger('select_select');
				// название склонения зависит от выбранного склонения, или если нет подходящих 
				//select вызовет is_void_sklon_name
			}
		}
		else
			set_value(form.other_num_edit, 
				(options.число && options.число=='мн') ? noun2singular(word) : noun2plural(word)
			);
		if(options.число){
			set_value(form.число, options.число);
			$(form.число).trigger('select_select');
			// #todo сделать form.число disabled
		}
		else{
			set_value(form.число,'ед');
			update_available();/*с целью вызова select(...)*/
		}
	}
	
	function get_data_for_save(){
		var data = {};
		data.wiki = form.wiki_flag.checked;
		if(form.other_num_flag.checked)
			data.other_num = form.other_num_edit.value;
		data.custom = selected==-1 || selected_modified;
		data.type = data.custom ? generate_type() : proper_types[selected].link;
		if(!data.custom && form.склонение.value != data.type.склонение)
			data.rename_type = form.склонение.value.trim();
		return data;
	}
	
	function save_data(data){
		var custom = data.custom;
		delete data.custom;
		if(custom){
			var id = DB.freeId('noun_types');
			DB.noun_types[id] = data.type;
		}
		else if(data.rename_type){
			data.type.склонение = data.rename_type;
			delete data.rename_type;
		}
		var other_num;
		if(data.other_num && data.other_num!=word && !DB.nouns.hasOwnProperty(data.other_num)){
			other_num = data.other_num;
			delete data.other_num;
		}
		DB.nouns[word] = data;
		if(options.need_link) 
			DB.nouns[options.need_link].other_num = word;
		//else console.log('need_link не обнаружен');
		if(other_num)
			dialog_add_noun(other_num,{ "число":invert_num(data.type.число), other_num: word, need_link: word });
		
		DB.commit(word,custom);// #todo need_link
	}
	$(form.OK).click(function(){ 
		set_value(form.other_num_edit, form.other_num_edit.value.trim());
		if(form.other_num_edit.value==='')
			set_checked(form.other_num_flag,false);
		if(form.other_num_flag.checked && form.other_num_edit.value===word && form.склонение.value!='несклоняемое' &&
			!confirm('слова во множественном и в единственном числе совпадают')
			){
			
			return;
		}
		set_value(form.склонение, form.склонение.value.trim());
		if(form.склонение.value===''){
			alert('название склонения не должно быть пустым');
			return;
		}
		save_data(get_data_for_save());
		dialog.close() 
		$style.remove();
	})
	
	function show_hide_buttons(show_h){
		if(show_h)
			$(form.OK).add(form.reset).show();
		else
			$(form.OK).add(form.reset).hide();
	}
	function compare_data(){
		if(!DB.nouns.hasOwnProperty(word))	return;
		var data = get_data_for_save();
		//if(data.custom)                                     console.log('отличие custom');
		//else if(data.rename_type)                           console.log('отличие склонение');
		//else if(data.type != DB.nouns[word].type)           console.log('отличие type');
		//else if(data.wiki != DB.nouns[word].wiki)           console.log('отличие wiki');
		//else if(data.other_num != DB.nouns[word].other_num) console.log('отличие other_num');
		show_hide_buttons(data.custom ||
			data.rename_type ||
			data.type != DB.nouns[word].type || 
			data.wiki != DB.nouns[word].wiki || 
			data.other_num != DB.nouns[word].other_num)
	}
	$(form.склонение).keydown(compare_data);
	$(form.склонение).change(compare_data);
	// вешается только если word in DB
	
	function reset(){
		if(DB.nouns.hasOwnProperty(word))
			init_from_DB();
		else
			init_without_DB();
	}
	$(form.reset).click(reset);
	
	function init(){
		//console.log('init');
		if(DB.nouns.hasOwnProperty(word)){
			init_from_DB();
			if(!form.other_num_flag.checked && options.other_num ){
				set_checked(form.other_num_flag, true);
				set_value(form.other_num_edit, options.other_num);
			}
			$(form.OK).text('изменить');
			$(form.other_num_flag).add(form.wiki_flag).change(compare_data)
			$(form.склонение).add(form.other_num_edit).keypress(compare_data);
			compare_data();
		}
		else{
			init_without_DB();
			$(form.reset).hide();
		}
	}
	init();
	
	// === запуск ==============================================================================================
	
	var dialog = new Dialog;
	$(form.cancel).click(function(){
		dialog.close()
		$style.remove();
	})
	dialog.show($form);
	//console.log('=== диалог создан ===')
}











function dialog_add_word(word,options){
	dialog_add_noun(word,options);
}



function parse(input_str){
	var tokenizer = rep(
		any(collect,
			rgx(/^[\w']+/).then(r=>r[0]),
			rgx(/^[,!\.\?]/).then(r=>({type:r[0]}))
		),rgx(/^\s*/));
	var arr = tokenizer.exec(input_str);
	alert(JSON.stringify(arr));
}





//===================================================================
//функции для загрузки загрузки
function schemas_init(){
var noun_schema = {
	$schema: 'my_meta_schema',
	id: 'noun',
	description: 'dictionary',
	type: 'object',
	required: ['noun_types','nouns'],
	properties: {
		noun_types: {
			id: 'noun_types',
			uniquePatternProperties: {
				'^[0-9]+$': {
					id: 'noun_type',
					required: [ "ип","рп","дп","вп","тп","пп","число","род","склонение" ],
					properties: {
						"ип": { type: 'string' },
						"рп": { type: 'string' },
						"дп": { type: 'string' },
						"вп": { type: 'string' },
						"тп": { type: 'string' },
						"пп": { type: 'string' },
						"число": { enum: [ 'ед','мн' ] },
						"род": { enum: [ 'м','ж','с','о' ] },
						"склонение": { type: 'string', minLength: 1 },
						"одушевленность": { type: [ 'boolean' ] },
					},
					additionalProperties: false,
				},
			},
			additionalProperties: false,
		},
		nouns: {
			patternProperties: {
				'^[а-яА-ЯёЁйЙ]+$': {
					id:'noun',
					required: [ 'type', 'wiki' ],
					properties: {
						type: { isPropertyOf: '/noun_types', parseCoerce: 'propLink', stringifyCoerce: 'propLink' },
						wiki: { type: ['boolean'] },
						other_num: { isPropertyOf: '/nouns' },
					},
					additionalProperties:true,
				},
			},
			additionalProperties:false,
		},
	},
	additionalProperties:true,
}
	schemas.addSchema('noun',noun_schema);
	var res = schemas.validate('my_meta_schema',noun_schema)
	if(res){
		console.dir(res);
		alert('noun схема не валидна');
	}
}
function load_init_DB(){
	/*
	localStorage.
	setItem(id, score)
	getItem(id)
	removeItem(id)
	clear();
	*/
	var DB =  JSON.parse(localStorage.getItem('DB'));
	DB.commit = function(path){//пока path игнорируем
		var errs = schemas.validate('noun',this,{useCoerce:'stringify'})
		if(errs) { 
			console.log('DB перед записью не соответствует noun-схеме:');
			console.dir(errs);
			console.dir(this);
			console.log('----');
			schemas.validate('noun',this,{useCoerce:'parse'})
			return;
		}
		localStorage.setItem('DB',JSON.stringify(this))
		var errs = schemas.validate('noun',this,{useCoerce:'parse'})
		if(errs) { 
			console.log('DB после записи не соответствует noun-схеме'); 
			console.dir(errs); 
			console.dir(this);
			console.log('----');
		}
	}
	DB.freeId = function(name){
		var n=-1;
		var u = users.current<<8;
		for(var i in this[name]){
			var x = +i;
			if(x>=u && x<u+256)
				if(x > n)
					n = x;
		}
		if(n+1 == u+256)
			_throw('пора реализовывать вторичный id пользователя');
		return n+1;
	}
	
	schemas_init();
	var errs = schemas.validate('noun',DB,{useCoerce:'parse'})
	if(errs) {
		console.log('DB не соответствует noun-схеме');
		console.dir(errs);
		console.dir(this);
		console.log('----');
		alert('DB не соответствует noun-схеме');
	}
	return DB;
}

//пока не предполагается создавать в нескольких экземплярах
function Users(){
	var self = this;
	//работа с DB
	this.DB = JSON.parse(localStorage.getItem('users'));//требование №1
	this.commit = function(){
		localStorage.setItem('users',JSON.stringify(this.DB));
	}
	//свойства
	this.all = this.DB.all;
	this.$selector = $('#user_name');//требование №2
	//изменение и добавление пользователей с синхронным изменением селектора и без коммитов
	Object.defineProperty(this, "current", {
		get: function() { return this.DB.current; },
		set: function(user) {
			if(user !== null)
				if(user>=0 && user<this.all.length){
					this.DB.current = user;
					this.$selector.val(this.DB.current);
				}
				else
					_throw('странный пользователь:'+user);
			else{
				this.DB.current = user;
				this.$selector.val('not_a_user');
			}
		}
	});
	//без проверки на уникальность, возвращает индекс добавленного
	this.add = function(user){
		var i = this.all.length;
		this.all[i] = user;
		this.$selector.append($('<option>').val(i).text(user));
		return i;
	}
	//инициализация селектора
	var $useropts=$().
			add($('<option>').val('not_a_user').text('не выбрано')).
			add($('<option>').val('add_user').text('Добавить пользователя'));
	this.all.forEach(function(name,i){
		$useropts = $useropts.add($('<option>').val(i).text(name))
	});
	this.$selector.change(change_user).append($useropts);
	this.current = this.DB.current;
	
	function change_user(){
		//alert('change')
		var $selector = $("#user_name");
		var name;
		if($selector.val() == 'add_user'){
			x:do{
				do{
					name = prompt("Введите имя (из англ. букв, цифр, и _)");
					if(!name)
						break x;
				}
				while(!/^\w+$/.test(name));
				if(self.all.indexOf(name)!=-1){
					alert('Такое имя уже есть, введите другое');
					var flag = true;
				}
				else flag = false;
			}
			while(flag)
			if(name){
				self.current = self.add(name);
				self.commit();
			}
			else
				self.current = null;
		}
		else{
			var selected = $selector.val();
			self.DB.current = selected=='not_a_user' ? null : selected;
		}
		self.commit();
		alert(self.current);
	}
}

function parse_URI_params(params) {
    var query = params.substring(1);
    var vars = query.split('&');
	var query_params = {};
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
		query_params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
	return query_params
}
function make_URI_params(options) {
	if(!options)	return '';
	var opts = [];
	for(var o in options)
		opts.push(encodeURIComponent(o)+'='+encodeURIComponent(options[o]));
	return '?'+opts.join('&');
}

function _throw(e){
	alert('всё упало!');
	throw e;
}

//===================================================================
//действия при загрузке 
// базы данных
var DB = load_init_DB();
var users = new Users;
// сохранение базовой строки
$('#in_text').val(localStorage.getItem('test_input'));
$(window).on('beforeunload', function(){
	localStorage.setItem('test_input',$('#in_text').val());
});

location.params = parse_URI_params(location.search);
if('word' in location.params){
	dialog_add_word(location.params.word,location.params);
}

console.log('test.html загружен');

//dialog_add_word($('#in_text').val())
</script>
</body>

</html>