существует "технология" память переводов
ее суть в том, чтобы одинаковые предложения переводились одинаковым способом
Если мы таким образом перевели некоторый текст, то потом переводить модифицированную версию этого текста будет гораздо проще, 
	т.к. надо будет перевести только измененные предложения.
Но какова вероятность встретить два одинаковых предложения в разных текстах?
	Если в предложении больше трех слов, то практически нулевая.
	
в этом тексте память переводов используется с другим смыслом
Предлагается сделать переводчик в котором единицей перевода будет не предложение, а фраза
	(словосочетания, слова - тоже являются фразами)
	причем английской фразе будет будет сопоставляться не ее перевод, а правило (алгоритм) генерации перевода
		фраза и правило перевода могут быть как очень простыми, так и очень сложными
	у одной и той же фразы может быть несколько смыслов, и соответственно, правил перевода
	совокупность фраз со всеми их правилами перевода - "память переводов" уровня языка - или проще говоря словарь фраз
в каждом конкретном тексте некоторая фраза имеет только один смысл (возможно с редкими исключениями)
	и выбор для каждой фразы варианта ее перевода из имеющихся - память переводов данного текста

==============================================================================

есть словарь фраз
есть память переводов (для каждого текста)

=== парсинг ===
(мульти)словарь фраз - ссылки от фраз на правила перевода
мульти - одна фраза может ссылаться на несколько правил
на одно правило перевода может идти несколько фраз

паттерн - БНФ
фраза - паттерн, который может использовать (также как одно предложение БНФ может использовать другие) паттерны, 
	называющиеся "типы (под)фраз",
тип подфразы - паттерн ИЛИ, использующий все фразы, имеющие этот тип (ф1 | ф2 | ф3 | ф4 | ...)
каждая фраза имеет один или несколько типов - сущ/глаг/прил/ или другая часть речи, которая может уточняться вопросом
типы фразы определяются типами правил, которыми может переводиться эта фраза

парсинг текста происходит по предложениям***
предложение парсится по очереди типами фраз, начиная с глагольного (или стартовым паттерном, который который использует другие фразы)

фразу будем называть терминальной или лексической, если ее паттерн не использует типы фраз
	примеры: [cat]; [fat]/*жирный*/
иначе фразу будем называть синтаксической или грамматической
	пример: [<прил> cat]
простые синтаксические фразы можно называть лексико-синтаксическими

фразу будем называть составной, если ее паттерн можно представить в виде
	синтаксической фразы (ее будем называть основной (в составе составной)), где хотябы вместо одного типа используется 
	конкретная фраза этого типа (такие фразы будем называть зависимыми (в составе составной))
		пример: [fat cat]
иначе фразу будем называть фразой 1-го уровня (простая фраза)
фраза n-го уровня состоит из фраз n-1-го и ниже уровней
а также, если фраза A является основной, а фразы B и C являются зависимыми в составе фразы X,
то со фразой A связана информация, ссылающаяся на фразы B,C и X

технически пасинг выглядит так:
текст (на клиенте) разбивается на слова, удаляются повторяющиеся слова, после чего на клиент загружаются все фразы 1го уровня, в которых эти слова встречаются
производится парсинг, после чего, какие-то фразы в тексте нашлись, 
и после этого на клиент загружются те фразы 2-го уровня, на которые ссылаются те фразы 1-го уровня, которые нашлись в тексте вместе с соответствующими зависимыми фразами.
в тексте ищутся фразы 2-го уровня в соответствующих местах...
и так далее
	например есть фраза [fat] и фраза [<прил> cat]
	на тексте [the fat cat] они будут найдены, и следовательно загрузится состовная фраза [fat cat]
	после чего она будет найдена, и она перекроет конструкцию из фраз [fat] и  [<прил> cat]


? как добавлять новые фразы, и что делать если текст можно распарсить разными способами ?
во первых каждое отдельное слово - изначально существующая фраза
а также как можно раньше надо сделать как можно более правильные грамматические фразы, чтоб они разбивали предложение с наибольшей глубиной вложенности
при коллизии фраз (один и тот же текст можно распарсить разными способами)
	у них сразу должна создаться (возможно вручную) составная фраза, 
	с набором правил, который является объединением наборов правил фраз, учавствующих в коллизии
	...

> на этом этапе почти не учитываю морфологию(словоформы), т.е. русский текст так не распарсишь
	хотя нет, распарсишь, только потребуется гораздо больше типов, различающихся по родам/числам/падежам/др_параметрам
	только для единообразия и упрощения должна быть связь между разными формами одного и того же слова
	и в переводе при выборе смысла он должен меняться у всех форм

=== перевод ===
каждая фраза может иметь нескоько смыслов, и соответственно несколько правил перевода
каким образом переводить ту или иную фразу - ВЫБИРАЕТ пользователь МЫШКОЙ ИЗ ВЫПАДАЮЩЕГО СПИСКА
после выбора* (или добавления) некоторого правила для некоторой фразы это правило записывается в память переводов данного текста, 
	и всегда, когда встречается эта фраза в этом тексте она по умолчанию будет переводиться этим правилом
* если в каком-то месте надо сделать исключение для для фразы, то из надфразы этой фразы как основной и этой фразы как зависимой
	создается состовная фраза, и добавляется в словарь фраз, после чего ей сопоставляется правило, в котором указано, 
	какие конкретно правила вызывать для основной и зависимой фразы, 
	а также эта составная фраза с этим правилом добавляется в память переводов этого текста.
***, * если у фразы нет надфраз, т.е. эта фраза - целое предложение, то наверно надо делать фразы содержащие несколько предложений...

чтобы для каждого нового текста схожей тематики не создавать заново вручную память переводов,
	ее можно инициализировать от другого/других текстов

=== генерация ===
каждое правило перевода имеет тип и один единственный смысл этого типа
(текст, сгенерированный этим правилом, может иметь и другие смыслы, но один из них (по возможности главный и очевидный)
	должен быть тем, для которого предназначено это правило)
и возвращает текст этого типа ввиде дерева, чтобы над ним было удобнее производить преобразования
правила для синтаксических фраз (т.е. синтаксические правила) принимают аргументы в виде деревьев определенного типа 
(от фраз, на которые ссылается(через типы фраз) фраза этого правила)
	синтаксические правила могут менять род/число/другие_параметры у своих аргументов
	а также изменять например глаголы на причастия/деепричастия или производить другие преобразования
	все эти преобразования возможны за счет существующей базы данных целевого языка**

также каждое правило может генерировать разные тексты ОДНОГО И ТОГО ЖЕ СМЫСЛА, 
	выбор между которыми усуществляется случайным образом или с применением статистических методов
	чтобы не было повторов слов в переводе и фраз типа масло масленое, а также из каких-нибудь других эстетических соображений
(цель перевода - не создать произведение искусства на целевом языке, а наиболее четко передать смысл)

в конце может захотеться выбрать конечный порядок слов
	но это решается либо за счет создания вариантов одного правила (какой вариант будет выбран - не имеет значения)
	либо за счет создания разных правил с разным смыслом

=== простой пример ===
фраза (ф1)[big] имеет правило(п1), которое возвращает [большой] типа прил
фраза (ф2)[fat] имеет правила: (п2)[жирный] (п8)[полный] и (п9)[толсый] типа прил
фраза (ф3)[cat] имеет правила: (п3)[кошка] и (п4)[кот] типа сущ
фраза (ф4)[<прил> <суш>] имеет правило (п5)[[<прил (того же рода, что и сущ)>] <суш>] типа сущ
	также с ней ассоциировано, что при аргументах (ф2) в качестве прил и (ф3)в качестве сущ она должна заменяться на (ф5)
фраза (ф5)[fat cat] имеет правила: (п6)[[полная] кошка] и (п7)[[толстый] кот] 
текст [big fat cat] с памятью переводов ф5-п6 будет переводиться так:
	фраза ф4 требует прил, т.е. ф1 или ф2, сработает ф1 (а ф2 не сработает), и big будет прочитано
	далее ф4 требует сущ, т.е. ф3 или ф4 (ф5 еще не загружена)
		ф3 не может быть прочитано (fat != cat)
		пытаемся прочитать ф4, 
			она требует прил, т.е. ф1 или ф2, и сработает ф2 (а ф1 не сработает), и fat будет прочитана 
			далее ф4 требует сущ, т.е. ф3 или ф4 (ф5 еще не загружена), и сработает ф3 (а ф4, если все это еще раз проделать, не сработает), и будет прочитано cat
			так как это ф4 с аргументами ф2 и ф3, то она замениться на ф5 (можно даже повторно не парсить)
			
			ф5 по памяти переводов переводится правилом п6
		и возвращает [[полная] кошка] типа сущ, с атрибутом ж.р.
		ф1 имеет одно правило п1 и возвращает [большой] типа прил
	ф4 преобразовывает [большой] в ж.р. и возвращает [[большая] [[полная] кошка]]
		
	 
=== мультилингва ===
поскольку каждое "правило" перевода имеет один единственный смысл
то ему можно сопоставить алгоритмы генерации текста для разных целевых языков

а также для разных исходных языков нужны будут свои фразы с алгоритмами парсинга

для одного исходного языка ссылки на составные фразы у разных целевых языков будут различаться

=== создание словаря фраз ===
каждый раз, когда требуется внести изменение в перевод, надо выбрать одно из трех:
	изменить правило, т.к. от изменения перевода в этом месте смысл не меняется
	изменить смысл фразы во всем тексте (а также, возможно, выбрать диапазон декста -
		выбрать оптимальный размер памяти переводов - для абзаца/страницы/главы)
	создать новую составную фразу-исключение
- это достаточно сложно автоматизировать

по этому автоматическая генерация словаря фраз из существующих пар текстов на мой взгляд невозможна
максимум, что можно сделать автоматически - это загрузка существующих словарей слов и маленьких фраз
остальное лучше предоставить пользователям в wiki-формате:
каждый может изменить словарь фраз, и в любой момент это изменение можно откатить

=== в двух словах: ===
wiki переводчик с памятью переводов для разных текстов
переводчик на основе правил, 
	предоставляющий варианты выбора и делающий умные выборы вариантов по умолчанию (на основе памяти переводов)
	правила которого могут менять и добавлять пользователи
		варианты выбора нужны чтобы нек. фразу в одном тексте переводить одним способом, а в другом - другим

=== БД: ===
англ. слова
	ссылки на фразы, в которых они содержатся (вычисляется автоматически)
англ. фразы (частный случай - англ. слова)
	ссылки на правила перевода и на составные фразы
правила перевода
	ссылки из правил на ру_слова (однозначные) и/или на ру_слова с уточненным смысла + взаимозаменяемость
русские слова с уточненным смысла
	ссылка на (слово, склонение) + ссылка на wiki
русские слова
	разные склонения/спряжения, + ссылка на wiktionary
	+ ссылка на wiki, возможно disambiguition (неоднозначное)
	
** есть определенные взаимосвязи между __ == атрибуты у __, ссылающиеся на __
	где __ - ру_слова (однозначные) и/или ру_слова с уточненным смысла
это нужно для замен (в правилах) типа: пикирующий<->который пикирует

=== как можно организовать ===
т.к. много чего будет калиброваться на практике, нужен язык, позволяющий легко это делать
например лисп или джаваскрипт 
а также поддерживающий легкую работу с древовидными структурами

перевод осуществлять в браузере пользователя(джаваскрипт), а на сервере хранить только БД
на клиент загружаются
	все англ. фразы, в которых встречаются слова текста.
	и (все русские слова (возможно с уточненным смысла) и русские слова, на которые ссылаются русские слова с уточненным смысла)
	которые используются в правилах, на которые ссылаются фразы
		или обновляются (в LocalStorage браузера) те которые уже загружены и были изменены другими пользователями
		запросы типа: 
			вот набор этих слов - загрузить, 
			набор этих слов - обновить с этого момента, 
			а набор этих слов - обновить с того момента.
		может быть стоит сформировать набор самых употребляемых слов, и не передавать в запросе все слова
			а только указание этого набора и последнюю дату его обновления.

> сделать скрипт (аналогичный mathjax), который можно будет встраивать в сайты, который будет 
	создавать GUI, 
	при выборе фраз и правил - обращаться серверу этого сайта за памятью переводов страниц с этого сайта
	давать возможность копировать/инициализоровать память переводов
	при редактировании фраз и правил - обращаться к вики-серверу фраз и правил
> сделать отдельный проэкт - хранилище памяти переводов любого сайта, 
	тексты можно идентифицировать при помощи URI, и память переводов для них хранить на общем для всего мира сервере
	GUI - аналог гугл-переводчика сайтов
	и, возможно в дальнейшем, плагины к браузерам, которые будут внедрять исх. код в код страниц
	на сайтах, где разным пользователям выдается один и тот же контент, 
		клиент может отправлять на сервер не список всех слов текста, а только его URL, 
		а на сервере уже будут закэшированы слова из того текста.

редактирование и хранение слов и фраз удобно привязать к вики-движку, у которого для каждого типа слов и фраз надо сделать 
	отдельный способ отображения и редактирования wisiwig (исходный код можно хранить например в JSON формате)

